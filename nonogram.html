<!DOCTYPE html>
<html>
	<head>
		<script src="https://cdn.jsdelivr.net/npm/vue@3.0.9/dist/vue.global.js"></script>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
		<style>

			table td {
				border: 1px solid #aaa;
				width: 20px;
				height: 20px;
			}

			table td.filled {
				background-color: #444;
			}

			table td.undecided {
				background-color: #a8b7c6;
			}
			table td.empty {
				background-color: white;
			}

			table tr.indexing td {
				border: 0;
				font-size: 10px;
				text-align: center;
				color: #aaa;
			}

			table tr.borders td {
				border: 0;
			}

			table tr.borders td.l {
				background-color: #d9b6d9;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			table tr.borders td.r {
				background-color: #efd38c;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			.data {
				font-family: monospace;
				font-size: 10px;
				color: #666;
				background: #fafafa; 
				border: 1px solid #ccc;
			}

		</style>
	</head>
<body>

	<div id="app">
		<div class="container mt-5">
			<div class='d-flex'>
				<input v-model='constraint' class='me-3'>		
				<table>
					<tr class="indexing">
						<td v-for="(cell, index) in cells">
							{{ index + 1 }}
						</td>
						
					</tr>
					<tr>
						<td v-for="(cell, index) in cells" @click="toggle_cell(index)" :class="status[cell.type]" :id="index">
							
						</td>
					</tr>
					<tr></tr>
					<tr class="borders">
						<td v-for="(cell, index) in cells" :id="index" :class="{ l:left_borders.includes(index), r: right_borders.includes(index) }">
							<span v-if="left_borders.includes(index)">L</span>
							<span v-if="right_borders.includes(index)">R</span>
						</td>
					</tr>

					<tr class="results">
						<td v-for="(result, index) in results" :class="status[result.type]" :id="index">
						</td>
					</tr>

					<tr class="indexing">
						<td v-for="(c, index) in considering" :id="index"> 
							{{ c }}
						</td>
					</tr>

				</table>
			</div>	
			<div>
				<div>
					<div class="data p-2 mt-2 d-inline-block">
						{{ parts }}
					</div>
				</div>
				<div>
					<div v-for="existing_part in existing_parts">
						<div class="data p-2 mt-2 d-inline-block">
						{{ existing_part }}
						</div>
					</div>
				</div>
			</div>	
			</div>
		</div>
	</div>
	<script type="text/javascript">

			//Vue.config.devtools = true;

			let size = 20;

			const app = Vue.createApp({
				data() {
					return {
						cells: [],
						constraint: null,
						parts: [],
						status: ['empty', 'undecided', 'filled'],
						left_borders: [],
						right_borders: [],
						results: [],
						considering: [],
						existing_parts: []
					}
				},
				created() {
					for(let i = 0; i < size; i++) {
						this.cells.push({type: 1});
						this.results.push({ type: 1 });
					}
				},
				watch: {
					constraint(new_constraint, old_constraint) {
						this.parts = new_constraint.split(',');
						this.parts = this.parts.map((n) => Number(n)); 

						this.length = this.parts.reduce((a, b) => a + b , 0) + (this.parts.length - 1);
						this.wiggle = size - this.length;	
					},

					parts(new_parts, old_parts) {
						this.update()
					}
				},
				methods: {
					update() {
						this.check_parts();
						this.get_parts();
						this.assign_parts();
					},
					toggle_cell(index) {
						this.cells[index].type += 1;
						if (this.cells[index].type > 2) {
							this.cells[index].type = 0
						}
						this.update()
					},

					get_parts() {

						this.existing_parts = [];

						let length = 0;
						let start = 0;

						for (let i = 0; i < this.cells.length; i++) {
							if (this.status[this.cells[i].type] != 'filled' && length > 0) {
								this.existing_parts.push({start: start, length: length, segments: []});
								length = 0;
							}
							if (this.status[this.cells[i].type] == 'filled') {
								if (length == 0) {
									start = i;
								}
								length++;
								
							}
						}
					},

					can_assign(existing_part, part_index) {
						if (existing_part.length > this.parts[part_index]) {
							return false;
						}

						if (existing_part.start <= this.right_borders[part_index] - this.parts[part_index]) {
							return false;
						}
						// @todo: klopt deze?
						if (existing_part.start + existing_part.length >= this.left_borders[part_index] + this.parts[part_index]) {
							return false;
						}

						// de rest van de constraints afspelen vanaf hier?

						return true;
					},

					next_letter(letter) {
						 return String.fromCharCode(letter.charCodeAt(0) + 1);
					},

					canConnect(a, b, part_index) {
						if (b.start >= a.start + this.parts[part_index]) {
							return false;
						}

						for (let i = a.start; i < a.start + this.parts[part_index]; i++) {
							if (this.status[this.cells[i].type] == 'empty') {
								return false;
							}

						}

						return true;

					},

					check_constraints(existing_part_index, part_index) {
						// left side


						// let expected = this.parts.length - part_index -1;
						// let parts = [];
						// let existing_part = this.existing_parts[existing_part_index];
						// let start = existing_part.start + existing_part.length; 

						// for (let i = start; i < size; i++) {

						// 	if (this.status[this.cells[i].type] != 'filled' && length > 0) {
						// 		parts.push({ length: length});
						// 		length = 0;
						// 	}
						// 	if (this.status[this.cells[i].type] == 'filled') {
						// 		length++;
						// 	}
						// }

						// console.log('---')
						// console.log('tested ep %s for pi %s', existing_part_index, part_index)
						// console.log('constraints found: %s, parts expected %s', parts, expected);

						// return (parts <= expected )

						// right

						//for (let i = part_index; i < this.parts.length)
						return true;
					},

					assign_parts() {
						let segment = 'A';

						// opties bepalen
						for (let i = 0; i < this.existing_parts.length; i++) {
							let offset = 0;
							let existing_part = this.existing_parts[i]
							for (let j = 0; j < this.parts.length; j++) {
								let part = this.parts[j];

								if (this.can_assign(existing_part, j)) {
									if (this.check_constraints(i, j)) {
										existing_part.segments.push(j)
									}
								} 
								// else {
								// 	segment = this.next_letter(segment);
								// 	continue;
								// }

								// offset += part + 1;
							}
								
						}

						// opties elmineren: 
						// kan er gewandeld worden van een naar ander
						for (let k = 0; k < this.existing_parts.length - 1; k++) {
							let existing_part = this.existing_parts[k];
							for (let l = 0; l < existing_part.segments.length; l++) {
								let LS = existing_part.segments[l];
								for (let m = k + 1; m < this.existing_parts.length; m++) {
									let neighbor = this.existing_parts[m];
									for (let n = 0; n < neighbor.segments.length; n++) {
										let RS = neighbor.segments[n];
										if (LS == RS) {
											if (!this.canConnect(existing_part, neighbor, LS)) {
												if (neighbor.segments.length > 1) {
													neighbor.segments.splice(n, 1);
												} else {
													existing_part.segments.splice(l,1);
												}
												
												
											console.log('KAN NIET: %s -> %s voor ', k, m, LS);
											}
										}
									}
								}
							}
						}

					},

					check_parts(parts) {

						if (!this.parts.length) {
							return
						}

						this.right_borders = [];
						this.left_borders = [];

						let last_border = 0;
						
						for (let i = 0; i < this.parts.length; i++) {
							let part = this.parts[i];
							
							last_border = this.determine_right_border(part, last_border, this.cells)
							this.right_borders.push(last_border)
							last_border += 2;
						};

						last_border = size - 1;

						for (let i = this.parts.length - 1; i > -1; i--) {
							let part = this.parts[i];
							last_border = this.determine_left_border(part, last_border, this.cells)
							this.left_borders.unshift(last_border)
							last_border -= 2;							
						};

						this.determine_results();
					},

					determine_right_border(part, start, array) {
						
						let space = part;

						for (let i = start; i < array.length; i++) {
							if(this.status[array[i].type] == 'filled') {

							}

							if(this.status[array[i].type] != 'empty') {
								space--
							} else {
								space = part;
							}

							if (space == 0) {
								return i;
							}
						}
					},
					
					determine_left_border(part, start, array) {
						let space = part;

						for (let i = start; i > -1; i--) {
							if(this.status[array[i].type] != 'empty') {
								space--
							} else {
								space = part;
							}

							if (space == 0) {
								return i;
							}
						}
					},
					
					determine_results() {

						let part_index = 0;
						this.results = [];
						this.considering = [];

						for (let i = 0; i < size; i++) {
							this.results.push({ type: 1 });
						}
						
						for (let i = 0; i < size; i++) {
							this.considering[i] = part_index;
							if (this.right_borders[part_index] - this.parts[part_index] >= i) {
								this.results[i] = { type: 0 }
							}
							if (this.left_borders[part_index] + this.parts[part_index] <= i) {
								this.results[i] = { type: 0 }
							}

							if (i >= this.left_borders[part_index] && i <= this.right_borders[part_index]) {
								this.results[i] = { type: 2 }
							}

							if (i == this.left_borders[part_index] + this.parts[part_index] - 1) {
								part_index++;
								if (part_index > this.parts.length - 1) {
									part_index = this.parts.length - 1;
								}
							}

						}

					}
				}
			})
			const vm = app.mount("#app")
	</script>
</body>
</html>
