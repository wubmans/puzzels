<!DOCTYPE html>
<html>
	<head>
		<script src="https://cdn.jsdelivr.net/npm/vue@3.0.9/dist/vue.global.js"></script>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
		<style>

			table td {
				border: 1px solid #aaa;
				width: 25px;
			}

			table td.filled {
				background-color: #444;
			}

			table td.possible {
				background-color: #a8b7c6;
			}
			table td.empty {
				background-color: white;
			}

			table tr.indexing td {
				border: 0;
				font-size: 10px;
				text-align: center;
				color: #aaa;
			}

			table tr.borders td {
				border: 0;
			}

			table tr.borders td.l {
				background-color: #d9b6d9;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			table tr.borders td.r {
				background-color: #efd38c;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			.data {
				font-family: monospace;
				font-size: 10px;
				color: #666;
				background: #fafafa; 
				border: 1px solid #ccc;
			}

		</style>
	</head>
<body>

	<div id="app">
		<div class="container mt-5">
			<div class="row">
			<div class='col-2'>
				<input v-model='constraint' class='me-3'>
				<div class="data p-2 mt-2 d-inline-block">
					constraints: <code>{{ constraints }}</code>
				</div>
				<div>
					possible: <code>{{ possible_parts.map((part) => { return part.length }) }}</code>
				</div>
				<div>
					actual: <code>{{ actual_parts.map((part) => { return part.length })  }}</code>
				</div>
				<br/>
				<br/>
				<button type="button" class="btn btn-secondary" @click="can_fit_constraints">Check if it fit's</button><br/><br/>
				<button type="button" class="btn btn-primary" @click="generate_output">Generate output</button>
			</div>
			<div class='col-10'>		
				<table>
					<tr class="indexing">
						<td>&nbsp;</td>
						<td v-for="(cell, index) in cells">
							{{ index + 1 }}
						</td>
						
					</tr>
					<tr>
					</tr>
					<tr>
						<td style="border: none" class="pe-3 text-muted"><small>input</small></td>
						<td v-for="(cell, index) in cells" @click="toggle_cell(index)" :class="status[cell.type]" :id="index"></td>
					</tr>
					<tr><td style="border: none">&nbsp;</td></tr>
					<tr class="output">
						<td style="border: none" class="pe-3 text-muted"><small>output</small></td>
						<td v-for="(o, index) in output" :class="status[o.type]" :id="index">
						</td>
					</tr>

					<tr class="indexing">
						<td v-for="(c, index) in considering" :id="index"> 
							{{ c }}
						</td>
					</tr>

				</table>
			</div>
		</div>	
			<div>
				<div>
		
				</div>
				<div>

				</div>
			</div>	
			</div>
		</div>
	</div>
	<script type="text/javascript">

			let size = 20;

			const app = Vue.createApp({
				data() {
					return {
						cells: [],
						constraint: null,
						constraints: [],
						status: ['empty', 'possible', 'filled'],
						output: [],
						considering: [],
						possible_parts: [],
						actual_parts: [],
					}
				},
				created() {
					for(let i = 0; i < size; i++) {
						this.cells.push({type: 1});
						this.output.push({ type: 1 });
					}

					//this.determine_parts(0, size, true);
				},
				watch: {
					constraint(new_constraint, old_constraint) {
						this.constraints = new_constraint.split(',');
						this.constraints = this.constraints.map((n) => Number(n)); 	
					},

					constraints() {
						this.update()
					}
				},
				methods: {
					update() {
						this.possible_parts = this.determine_parts(this.cells, 0, size, true);
						this.actual_parts = this.determine_parts(this.cells, 0, size);
						//this.can_fit_constraints();
					},

					get_cell(index) {
						return this.status[this.cells[index].type];
					},
					set_cell(index, status) {
						this.cells[index].type = this.status.indexOf(status);
					},

					toggle_cell(index) {
						this.cells[index].type += 1;
						if (this.cells[index].type > 2) {
							this.cells[index].type = 0
						}
						this.update()
					},

					get_constraints_length(constraints) {
						let length = 0;
						for (let i = 0; i < constraints.length; i++) {
							length += constraints[i];
							if (i < constraints.length - 1) {
								length++;
							}
						}
						return length;
					},

					determine_parts(cells, start, stop, possible) {

						let parts = []

						let length = 0;
						let left = 0;
						let right = 0;

						let finish_part = (i) => {
							if (length > 0) {
								parts.push({ length: length, left: left, right: i })
								length = 0;
							}
						}

						let build_part = (i) => {
							if (length === 0) {
								left = i;
							}
							length++ 
						}

						for (let i = start; i < stop; i++) {
							switch(this.status[cells[i].type]) {
								case 'filled': 
									build_part(i);
									break;
								case 'possible':
									possible ? build_part(i) : finish_part(i);
									break;
								case 'empty':
									finish_part(i);
									break;

							}
						}

						if (length > 0) {
							parts.push({ length: length, left: left, right: size })
						}

						return parts;
					},

					generate_output() {
						if (!this.can_fit_constraints(this.cells)) {
							return;
						}

						let cells = [];

						for (let k = 0; k < size; k++) {
							cells.push({ type: 1 })
						}

						for (let i = 0; i < size; i++) {
							this.output[i].type = 1;

							if (this.get_cell(i) != "possible") {
								cells[i].type = this.cells[i].type;
								this.output[i].type = this.cells[i].type;
								continue;
							}
								
							cells[i].type = 0;
							if (!this.can_fit_constraints(cells)) {	
								console.log('nope, not possible')	
								cells[i].type = 2;
								this.output[i].type = 2;
								continue;
							}

							// cells[i].type = 2;
							// if (!this.satisfies_constraints(cells)) {									
							// 	cells[i].type = 0;
							// 	this.output[i].type = 0;	
							// 	continue;				
							// }

							cells[i].type = 1;
					
						}
					},

					// even simpele max min
					satisfies_constraints(cells) {

						let max = Math.max.apply(Math, this.constraints);
						let min = Math.min.apply(Math, this.constraints);

						let parts = this.determine_parts(cells, 0, size);
						for (let i = 0; i < parts.length; i++) {
							if (parts[i].length > max) {
								console.log('no cigar');
								return false;
							}
						}

						return true;

					},

					can_fit_constraints(cells) {
						let index = 0;

						if (this.constraints.length == 0) {
							return true;
						}

						let c = [...this.constraints];
						let possible_parts = this.determine_parts(cells, 0, size, true);

						return this.can_fit(c, possible_parts);
					},

					can_fit(c, p) {
						if (!c.length){
							return true;
						}

						let length;

						// past alles in een van de vakjes?
						length = this.get_constraints_length(c);
						for (let i = 0; i < p.length; i++) {
							if (p[i].length >= length) {
								//console.log("%s fits at %s in %s with no remainder", length, i, p[i].length)
								return true;
							}
						}

						//console.log("%s doesnt fit in %s, maybe if we spread parts", length, p)

						// nee. Past de eerste constraint ergens en de rest in de rest?
						let part = c.shift();

						for (let i = 0; i < p.length; i++) {
							if (p[i].length >= part) {
								//console.log("%s fits in %s", part, p[i].length)
								//console.log("lets check remainder: ", c, [...p].splice(i+1))
								return this.can_fit(c, p.splice(i+1))
							}
						}

						//console.log('ITS TOO BIG!')
					}
				}
			})
			const vm = app.mount("#app")
	</script>
</body>
</html>
