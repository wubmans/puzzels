<!DOCTYPE html>
<html>
	<head>
		<script src="https://cdn.jsdelivr.net/npm/vue@3.0.9/dist/vue.global.js"></script>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
		<style>

			table td {
				border: 1px solid #aaa;
				width: 25px;
			}

			table td.filled {
				background-color: #444;
			}

			table td.possible {
				background-color: #a8b7c6;
			}
			table td.empty {
				background-color: white;
			}

			table tr.indexing td {
				border: 0;
				font-size: 10px;
				text-align: center;
				color: #aaa;
			}

			table tr.borders td {
				border: 0;
			}

			table tr.borders td.l {
				background-color: #d9b6d9;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			table tr.borders td.r {
				background-color: #efd38c;
				text-align: center;
				font-size: 10px;
				color: white;
				font-weight: bold;
			}

			.data {
				font-family: monospace;
				font-size: 10px;
				color: #666;
				background: #fafafa; 
				border: 1px solid #ccc;
			}

		</style>
	</head>
<body>

	<div id="app">
		<div class="container mt-5">
			<div class="row">
			<div class='col-2'>
				<input v-model='constraint' class='me-3'>
				<div class="data p-2 mt-2 d-inline-block">
					constraints: <code>{{ constraints }}</code>
				</div>
				<div>
					possible: <code>{{ possible_parts.map((part) => { return part.length }) }}</code>
				</div>
				<div>
					actual: <code>{{ actual_parts.map((part) => { return part.length })  }}</code>
				</div>
				<br/>
				<br/>
				<button type="button" class="btn btn-secondary" @click="can_apply_constraints">Check if it fit's</button><br/><br/>
				<button type="button" class="btn btn-primary" @click="generate_output">Generate output</button>
			</div>
			<div class='col-10'>		
				<table>
					<tr class="indexing">
						<td>&nbsp;</td>
						<td v-for="(cell, index) in input">
							{{ index }}
						</td>
						
					</tr>
					<tr>
					</tr>
					<tr>
						<td style="border: none" class="pe-3 text-muted"><small>input</small></td>
						<td v-for="(i, index) in input" @click="toggle_cell(index)" :class="status[i]" :id="index"></td>
					</tr>
					<tr><td style="border: none">&nbsp;</td></tr>
					<tr class="output">
						<td style="border: none" class="pe-3 text-muted"><small>output</small></td>
						<td v-for="(o, index) in output" :class="status[o]" :id="index">
						</td>
					</tr>

				</table>

				<div class="data m-2">
					<pre>{{ messages }}</pre>
				</div>
			</div>
		</div>	
			<div>
				<div>
		
				</div>
				<div>

				</div>
			</div>	
			</div>
		</div>
	</div>
	<script type="text/javascript">

			let size = 20;

			const app = Vue.createApp({
				data() {
					return {
						input: [],
						output: [],
						draft: [],
						constraint: null,
						constraints: [],
						status: ['empty', 'possible', 'filled'],
						possible_parts: [],
						actual_parts: [],
						messages: []
					}
				},
				created() {
					for(let i = 0; i < size; i++) {
						this.input.push(1);
						this.draft.push(1);
						this.output.push(1);
					}

					//this.determine_parts(0, size, true);
				},
				watch: {
					constraint(new_constraint, old_constraint) {
						this.constraints = new_constraint.split(',');
						this.constraints = this.constraints.map((n) => Number(n)); 	
					},

					constraints() {
						this.update()
					},
					input() {
						this.update()
					},
					messages()  {
						this.$forceUpdate();
					}
				},
				methods: {

					update() {
						//this.possible_parts = this.determine_parts(this.input, 0, size, true);
						//this.actual_parts = this.determine_parts(this.input, 0, size);
						//this.can_fit_constraints();
					},

					toggle_cell(index) {
						this.input[index] += 1;
						if (this.input[index] > 2) {
							this.input[index] = 0
						}
					},

					get_constraints_length(constraints) {
						let length = 0;
						for (let i = 0; i < constraints.length; i++) {
							length += constraints[i];
							if (i < constraints.length - 1) {
								length++;
							}
						}
						return length;
					},

					determine_parts(cells, start, stop, include_possible) {

						let parts = []

						let length = 0;
						let left = 0;
						let right = 0;

						let finish_part = (i) => {
							if (length > 0) {
								
								parts.push({ length: length, left: left, right: i - 1 })
								length = 0;
							}
						}

						let build_part = (i) => {
							if (length === 0) {
								left = i;
							}
							length++ 
						}

						for (let i = start; i < stop; i++) {
							//
							switch(cells[i]) {
								case 2: 
									build_part(i);
									break;
								case 1:
									include_possible ? build_part(i) : finish_part(i);
									break;
								case 0:
									finish_part(i);
									break;

							}
						}

						// possible remaining part
						if (length > 0) {
							
							finish_part(stop);
							//parts.push({ length: length, left: left, right: stop })
						}

						return parts;
					},

					generate_output() {

						this.draft = [...this.input];

						for (let i = 0; i < size; i++) {

							
							

							this.output[i] = 1;

							if (this.input[i] != 1) {
								this.draft[i] = this.input[i];
								this.output[i] = this.input[i];
								continue;
							}
								
							this.draft[i] = 0;
							if (!this.can_apply_constraints(this.draft)) {	
								
								this.draft[i] = 2;
								this.output[i] = 2;
								continue;
							}

							this.draft[i] = 2;
							if (!this.can_apply_constraints(this.draft)) {						
								
								this.draft[i] = 0;
								this.output[i] = 0;	
								continue;				
							}

							this.draft[i] = 1;

							
					
						}
					},

					can_apply_constraints(cells) {
						let index = 0;

						if (this.constraints.length == 0) {
							return true;
						}

						let constraints = [...this.constraints];
						let actual_parts = this.determine_parts(cells, 0, size);
						let possible_parts = this.determine_parts(cells, 0, size, true);

						return result = this.can_fit(cells, constraints, actual_parts, possible_parts, 0)
					},

					can_fit(cells, constraints, actual_parts, possible_parts, start) {
						


						if (start >= size && constraints.length > 0) {
							
							// array is op
							return false;
						}
						
						if (actual_parts.constructor != Array) {
							console.log("***** NOT AN ARRAY ****")
						}

						if (constraints.length === 0) {
							if (actual_parts.length > 0) {
								console.log(actual_parts)
								return false;
							}
						}

						let length;

						/*
						 *		no actual parts
						 *
						 */

						 // @todo: fix this error in copying arrays
						if (actual_parts.length === 0 || !actual_parts[0]) {

							

							length = this.get_constraints_length(constraints);
							

							
							for (let i = 0; i < possible_parts.length; i++) {
								if (possible_parts[i].length >= length) {
									return true;
								}
							}

							// nee. Past de eerste constraint ergens en de rest in de rest?
							let _constraints = [...constraints];
							let part = _constraints.shift();

							for (let i = 0; i < possible_parts.length; i++) {
								if (possible_parts[i].length >= part) {
									return this.can_fit(cells, _constraints, actual_parts, possible_parts.splice(i+1))
								}
							}

							return false;
						}

						/*
						 *		actual parts
						 *
						 */



						for (let j = 0; j < actual_parts.length; j++) {

							let actual_part = actual_parts[j];
	
							if (start + actual_part.length > size) {
								
								return false;
							}

							for (let k = 0; k < constraints.length; k++) {
								let constraint = constraints[k];

								// same size
								if (actual_part.length == constraint) {									
									let a_remaining = [...actual_parts].splice(j + 1);
									let c_remaining = [...constraints].splice(k + 1)
									let s_remaining = actual_part.right + 1


									if (this.can_fit(cells, c_remaining, a_remaining, possible_parts, s_remaining)) {
										return true;
									}
								}

								if (actual_part.length < constraint) {	
																	
									let r = this.part_can_grow(cells, actual_part, constraint);
									
									;
									if (r !== false) {
										let a_remaining = [...actual_parts].splice(j + 1);
										let c_remaining = [...constraints].splice(k + 1)
										let s_remaining = r + 1;		
								
										if (this.can_fit(cells, c_remaining, a_remaining, possible_parts, s_remaining)) {
											return true;
										} else {
											// see if we can continue growing into actual_parts to the right
											for (let l = j + 1; l < actual_parts.length; l++) {
												let neighbor = actual_parts[l];
												let r = this.part_can_grow(cells, neighbor, constraint);

												if (r !== false && (r + 1 - constraint) <= actual_part.left) {
													
													let a_remaining = [...actual_parts].splice(l + 1);
													let c_remaining = [...constraints].splice(k + 1)
													let s_remaining = r + 1;
													if (this.can_fit(cells, c_remaining, a_remaining, possible_parts, s_remaining)) {
														return true;
													}
												}
											}
										}
									}
								}

								// can't fit this constraint; push left and continue
								let r = this.fit_constraint(cells, constraint, start, actual_part.left);
								if (r !== false) {
									let c_remaining = [...constraints].splice(k + 1)
									let s_remaining = r + 1;
									if (this.can_fit(cells, c_remaining, actual_parts, possible_parts, s_remaining)) {	
										return true;
									}
								}
								
								return false;
							}
						}

					},

					part_can_grow(cells, part, required) {

						let difference = required - part.length;

						let i = part.left  - difference;
						let j = part.right + difference;

						if (i < 0) {
							i = 0;
						}

						if (j > size - 1) {
							j = size - 1;
						}

						let length = 0;
						let right = 0;

						

						for (let k = i; k <= j; k++) {
							if (cells[k] != 0) {
								length++
								

								right = k;

								if (length == required) {
									break;
								}
							} else {
								
								length = 0;
							}
						}
						

						

						if (length != required) {
							return false;
						}
						
						return right;
					},

					fit_constraint(cells, required, start, stop) {

						let length = 0;
						let right = 0;

						for (let k = start; k < stop; k++) {
							if (cells[k] != 0) {
								length++
								

								right = k;

								if (length == required) {
									break;
								}
							} else {
								
								length = 0;
							}
						}

						if (length != required) {
							return false;
						}

						return right;
					}


						// code voor geen actual_parts

						/*

						// past alles in een van de vakjes?


						*/

						//
					
				}
			})
			const vm = app.mount("#app")
	</script>
</body>
</html>
